// this is the code I referred to from kotatsugame for learning purposes.
// https://atcoder.jp/contests/abc189/submissions/19611100
// 方針:確率DP
#include<iostream>
#include<iomanip>
using namespace std;
int N,M,K;
int A[11];  // 振り出しマスのインデックスを格納する配列 A
double da[2<<17],db[2<<17];
// da[i]: マス i からゴールするまでに必要なルーレットの回転数の期待値。
// db[i]: マス i からゴールするまでのプレイ中に振り出しに戻される確率。
bool out[1<<17];  // 振り出しマスを識別するためのブール配列out
main()
{
	cin>>N>>M>>K;
	for(int i=0;i<K;i++)
	{
		cin>>A[i];
		out[A[i]]=true;
	}
  // sa: da[i] の累積和。特定の範囲のマスにおける期待値の合計を計算するために使用
	// sb: db[i] の累積和。特定の範囲のマスにおける戻される確率の合計を計算するために使用
	double sa=0,sb=0;
	for(int i=N;i--;)
	{
		if(out[i])db[i]=1;
		else
		{
			da[i]=sa/M+1;
			db[i]=sb/M;
			// sa が M 個先までのマスからゴールまでのルーレットの回数の期待値の和を表すか？ - はい。
			// sb/M が M 個先までのマスからゴールまでで出戻りする確率の和（それぞれのマスに移動する確率を乗じたもの）を表すか？ - はい。
		}
		// sa,sbはそれぞれM個先までのマスの期待値の和なので、ループが前のマスに1マス進むごとに1マスごとにそのM個のマスのまとまりを左にずらす
		sa+=da[i];
		sb+=db[i];
		sa-=da[i+M];
		sb-=db[i+M];
	}
	double ans;
	if(K==0)ans=da[0];
	else if(db[0]<1-1e-8)	// 1e-8:10^(-8)を意味→厳密には1になることはないとしても事実上到達しない場合、を除外するための判定文
	// →else if(db[0]<1-1e-8) は、db[0]（スタート地点からゴールに到達する前に振り出しに戻る確率）が「事実上の 100%」より小さいかどうかをチェックしています。この判定は、振り出しに戻る確率が 100% に非常に近いが、完全には 100% に達していない場合（つまり、ゴールに到達する可能性が微小でも存在する場合）を検出するためにあります。
	{
		ans=da[0]/(1-db[0]);
		// da[0] は、スタート地点からゴールまでのルーレットの回数の期待値を表しますが、これは振り出しに戻らない場合のみの期待値です。
		// 1-db[0] は、振り出しに戻らない（つまり、直接ゴールする）確率を表します。したがって、da[0] を 1-db[0] で割ることで、振り出しに戻る可能性を考慮した全体の期待値を求めることができます。
	}
	else
	{
		cout<<-1<<endl;
		return 0;
	}
	cout<<fixed<<setprecision(16)<<ans<<endl;
}

// ☆以下主要なループ部分の説明
// 具体的なデータを使って、このコードの動作を説明しましょう。例として、N=5（マスの数）、M=2（ルーレットの最大値）、K=1（振り出しマスの数）とし、振り出しマスが A[0]=3 の場合を考えます。この設定でコードの動作をステップバイステップで追ってみましょう。

// 初期化:

// da と db は、それぞれ期待値と振り出しに戻る確率を格納する配列です。初期化された状態では、すべての値は 0 です。
// out[3] は真となります（マス3が振り出しマスです）。
// 逆順の走査:
// マス 5（ゴール）からマス 0（スタート）に向かって、各マスの期待値と振り出しに戻る確率を計算します。
// マス 5（ゴール）:
// da[5] と db[5] はそのまま 0 です（ゴールにはすでにいますので、ルーレットを回す必要も、振り出しに戻るリスクもありません）。
// sa と sb はそれぞれ 0 です。
// マス 4:
// da[4] = sa/M + 1 = 0/2 + 1 = 1 （ゴールに到達するために平均して1回ルーレットを回す必要があります）。
// db[4] = sb/M = 0/2 = 0 （振り出しに戻るリスクはありません）。
// sa と sb は更新され、sa = 1、sb = 0 となります。
// マス 3（振り出しマス）:
// db[3] = 1 （このマスに到達した場合、必ず振り出しに戻されます）。
// sa と sb は更新され、sa = 1、sb = 1 となります。
// マス 2:
// da[2] = sa/M + 1 = 1/2 + 1 = 1.5 （ゴールに到達するために平均して1.5回ルーレットを回す必要があります）。
// db[2] = sb/M = 1/2 = 0.5 （振り出しに戻る確率は 50%）。
// sa と sb は更新され、sa = 2.5、sb = 1.5 となります。
// マス 1 と マス 0 についても同様に計算を繰り返します。

// この逆順走査により、各マスでの期待値と振り出しに戻る確率が効率的に計算され、最終的にマス 0 の期待値 da[0] が求められます。これがゴールするまでにルーレットを回す回数の期待値となります。
