#include <bits/stdc++.h>
using namespace std;

#define rep(i,x) for(int i=0;i<(x);i++)

int main(){
  int n;
  cin>>n;

  // n*nの２次元配列dを初期化
  vector<vector<int>> d(n,vector<int>(n,0));
  rep(i,n){
    // iを固定した状態でjに対してループ処理を実行;i=0の時、j=1からj++をしながら繰り返す→与えられた頂点iとそれより大きな番号をもつ頂点との愛dの各辺の重みを入力から読み取る。：無向グラフなので各ペアの頂点間には一つの辺しかなく、重みが2回与えられることはないため。→問題の入力例参照
    for(int j=i+1;j<n;j++)cin>>d[i][j];
  }

  // dpという動的計画法のテーブル(大きさ2^nの1次元配列)を初期化、各要素はlong long型。1<<n：2のn乗を計算することを意味。
  vector<long long> dp(1<<n,0ll); //①1<<nは1をnだけビット演算として左シフトした数、つまり、2^nで、dpの要素数の指定　②0ll：ll=long long、各要素のリテラルの型の指定、0：ll型の値0で各要素を初期化、を意味

  // 外側のループ：dpテーブルの各状態を順に処理するためのもの。bは0から2^n-1までの整数で、どの頂点が既に選ばれているかを表現している。例：N=3,b=5のとき、bは101_[2]と表現されるため、1番目と3番目の頂点が既に何らかの辺で選ばれていることを意味する。
  rep(b,(1<<n)-1){
    int l=-1; //lは未選択の頂点の中で最もインデックスが小さいものを指す。
    rep(i,n)if(!(b>>i&1)){  //bを右にiビットシフト→i番目のビットが最も下位の位置に移動→&1によりそのビットが1か0かを判定→0の場合内部処理を実行
      l=i;  //未選択の頂点の中で最もインデックスが小さいものが見つかったのでそれを扱うためのパラメータlに格納しループを抜ける
      break;  //lにiが設定されたらループを抜ける
    }
    // 状態bに対して、未選択の全てのインデックスjに対する走査処理→l=jの場合も一度は処理されるが、未選択のjおよびlに対して考えうるすべての枝の重み、をdp[nb] = max(dp[nb], dp[b] + d[l][j]);の部分で比較、新しいものが大きければ更新、を繰り返し全ての場合から最大解を得る。
    rep(j, n) if(!(b >> j & 1) && j !=l) {
			int nb = b | (1 << l) | (1 << j);
			dp[nb] = max(dp[nb], dp[b] + d[l][j]);  //dp[nb]: nbという状態（ここでの状態はビットセット）における最大値。→要素に入る値が常に正とは限らず、一般性を持たせるためのmax関数による判定処理
  }
}
  cout<<dp.back()<<endl;
}