// 計算量：O(N)
#include <bits/stdc++.h>
using namespace std;

int main(){
  int n,d,k;
  long long p;  //1日周遊パスのセットの価格；d日分(一括で購入しなければいけない)
  cin>>n>>d>>p;

  vector<long long>f(n),s(n);
  for(int i=0;i<n;i++)cin>>f[i];  //各日数の運賃リストfを標準入力から読み込む、fベクターはn日分の運賃の通常料金をデータとして持つ

  sort(f.begin(),f.end());  //運賃のリストを昇順にソートする、f.begin(),f.end()はそれぞれfの最初、最後のインデックスを指す
  s[0]=f[0];  //累積和の計算を開始するために代入
  for(int i=0;i<n-1;i++)s[i+1]=s[i]+f[i+1]; //累積和を計算

  k=(n+d-1)/d;  //n日をカバーしきる1日周遊パスセットの個数の計算；余りは切り捨て、分子のd-1はn/dの端数により繰り下げになることを防ぐ、つまり繰り上げになるようにするための処理、dは一日周遊パスセットの1セット当たりの日数分
  long long ans=p*k;
  for(int i=0;i<k;i++){
    ans=min(ans,s[n-1-(i*d)]+(p*i));
  } //i：1日周遊パスを使用する日数

  cout<<ans<<endl;

  return 0;

}

// 追記：ベクター：C++のSTL(Standard Template Library)に属する動的配列の一種で、要素の追加や削除が容易
// 動的サイズ: 配列とは異なり、ベクターのサイズは動的です。要素を追加するとサイズが増え、要素を削除するとサイズが減少。
// ランダムアクセス: 配列のように、インデックスを使用してO(1)の時間で要素にアクセス可能
// 連続したメモリ: ベクターの要素は連続したメモリ位置に格納されます。これにより、イテレータを使用して要素に効率的にアクセス可能