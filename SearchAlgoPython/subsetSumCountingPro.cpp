#include <bits/stdc++.h>
using namespace std;
#define rep(i,m,x) for(int i=m;i<(x);i++)
typedef long long ll;
// 部分和数え上げ問題
// 問:n個の整数を選ぶことで総和が正の整数aになる方法が何通りあるかを求めよ。ただし、答えがとても大きくなる可能性があるので、1,000,000,009で割った余りで出力せよ。
// 方針:①1,000,000,009は素数→モジュ―ラアリズム;素数をモジュロとして使用することで逆元が存在するため、除算のような操作も可能になる＋すべての計算を同じモジュロで行うことで答えが一意になる。
// ②求める数が、aになる方法の場合の数なので、dpの各要素にはi番目の試行で合計がjになる場合の数を保持する。→メイン処理の走査
const int mod=1000000009; // 1,000,000,009は素数→素数モジュ―ラ計算の導入による各計算過程の出力の簡便性＋答の一意性＋計算の効率化を実現

int main(){
  int n,a;
  cin>>n>>a;
  vector<int> num(n);
  rep(i,0,n)cin>>num[i];
  // dpの宣言・初期化
  vector<vector<int>> dp(n,vector<int>(10010,0));
  dp[0][0]=1;

  // メイン処理;dp[i][j]:最初のi個の整数を使用して合計がjになる組の数
  rep(i,0,n)rep(j,0,a+1){
    (dp[i+1][j]+=dp[i][j])%=mod;
    // 合計jがnum[i]より大きい場合、i+1回目の走査時に選択した数の総和がjとなる'場合の数'を保持する要素dp[i+1][j]に、i回目の走査時の総和がj-num[i]となるような場合の数を足し合わせる
    if(j>=num[i])(dp[i+1][j]+=dp[i][j-num[i]])%=mod;
  }

  cout<<dp[n][a]<<endl;

  return 0;

}
